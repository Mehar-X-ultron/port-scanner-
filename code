#!/usr/bin/env python3
"""
port_scanner_simple.py
A beginner-friendly TCP port scanner using threads.

Usage examples:
  python3 port_scanner_simple.py --host 127.0.0.1 --start 1 --end 1024
  python3 port_scanner_simple.py --host localhost --ports 22,80,443

Note: Only scan machines you own or have permission to test.
"""

import socket
import argparse
from concurrent.futures import ThreadPoolExecutor, as_completed
from typing import List

DEFAULT_TIMEOUT = 1.0
MAX_THREADS = 100

def parse_ports(ports_str: str) -> List[int]:
    ports = set()
    for part in ports_str.split(','):
        part = part.strip()
        if not part:
            continue
        if '-' in part:
            a, b = part.split('-', 1)
            a, b = int(a), int(b)
            for p in range(max(1, a), min(65535, b) + 1):
                ports.add(p)
        else:
            p = int(part)
            if 1 <= p <= 65535:
                ports.add(p)
    return sorted(ports)

def is_open(ip: str, port: int, timeout: float) -> bool:
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            s.settimeout(timeout)
            s.connect((ip, port))
            return True
    except Exception:
        return False

def scan_ports(ip: str, ports: List[int], timeout: float, threads: int):
    open_ports = []
    with ThreadPoolExecutor(max_workers=threads) as ex:
        futures = {ex.submit(is_open, ip, p, timeout): p for p in ports}
        for fut in as_completed(futures):
            p = futures[fut]
            try:
                if fut.result():
                    print(f"[OPEN]  {p}")
                    open_ports.append(p)
                else:
                    # Uncomment next line to see closed ports
                    # print(f"[closed] {p}")
                    pass
            except Exception as e:
                print(f"[error] port {p}: {e}")
    return open_ports

def main():
    parser = argparse.ArgumentParser(description="Simple threaded TCP port scanner (educational).")
    parser.add_argument("--host", required=True, help="Target hostname or IP (authorized targets only).")
    parser.add_argument("--start", type=int, default=1, help="Start port (default 1).")
    parser.add_argument("--end", type=int, default=1024, help="End port (default 1024).")
    parser.add_argument("--ports", help="Comma-separated ports/ranges e.g. 22,80,8000-8010 (overrides start/end).")
    parser.add_argument("--timeout", type=float, default=DEFAULT_TIMEOUT, help=f"Connection timeout in seconds (default {DEFAULT_TIMEOUT}).")
    parser.add_argument("--threads", type=int, default=50, help="Number of worker threads (default 50).")
    args = parser.parse_args()

    # build ports list
    if args.ports:
        ports = parse_ports(args.ports)
    else:
        start = max(1, args.start)
        end = min(65535, args.end)
        if end < start:
            print("Invalid port range.")
            return
        ports = list(range(start, end + 1))

    if len(ports) > 20000:
        print("Refusing to scan more than 20000 ports at once. Reduce range or use --ports.")
        return

    # resolve host
    try:
        ip = socket.gethostbyname(args.host)
    except socket.gaierror:
        print("Failed to resolve host:", args.host)
        return

    print(f"Scanning {args.host} ({ip}) ports {ports[0]}-{ports[-1]}  timeout={args.timeout}s threads={args.threads}")
    open_ports = scan_ports(ip=ip, ports=ports, timeout=args.timeout, threads=min(args.threads, MAX_THREADS))

    if open_ports:
        print("\nOpen ports found:", ", ".join(map(str, open_ports)))
    else:
        print("\nNo open ports found in the scanned range.")

if __name__ == "__main__":
    main()
